import { idIsComponent } from ".";
import { JSX } from '../lib/types';

// export interface IElement<P> {
//   identifier: string | IElement<P>;
//   props: P;
//   children: ElementChildren;

//   readonly htmlString: string;
// }

export type ElementChildren = (string | number | boolean | DeprecatedElement<any> | null)[];

/**
 * The main type of output generated by JSXEngine.run.
 */
export default class DeprecatedElement<P> {
  public identifier: string | DeprecatedElement<P>;
  public props: P | null;
  public children: ElementChildren;

  constructor(identifier: string | DeprecatedElement<P>, props: P | null, ...children: ElementChildren) {
    this.identifier = identifier;
    this.props = props;
    this.children = children;
  }

  get htmlString(): string {
    let renderedChildren: string;
    if (childrenAreElements(this.children)) {
      renderedChildren = this.children
        .map(c => c.htmlString)
        .join('');
    } else if (childrenContainsStringOutput(this.children)) {
      renderedChildren = '';
      // TODO: refactor to use ternary operator
      for (const child of this.children) {
        if (child instanceof DeprecatedElement) {
          renderedChildren += child.htmlString;
        } else {
          renderedChildren += child;
        }
      }
    } else {
      renderedChildren = '';
    }

    const propString = this.getHtmlAttributes();
    const tag = propString ? `${this.identifier}${propString}` : this.identifier;
    return `<${tag}>${renderedChildren}</${this.identifier}>`;
  }

  private getHtmlAttributes() {
    if (this.props === null || Object.entries(this.props as P).length < 1) {
      return null;
    }
    // TODO: add type safety so that value is not any.
    return Object.entries(this.props as P)
      .reduce((attributes, [key, value]) => {
        if (key === 'className') key = 'class';
        return attributes + ` ${key}="${String(value)}"`
      }, '');
  }
}

function idIsElement(identifier: string | DeprecatedElement<any>): identifier is DeprecatedElement<any> {
  if (typeof identifier === 'string') {
    return false;
  }

  if (identifier instanceof DeprecatedElement) {
    return true;
  }

  throw new Error('identifier must be an instance of String or Element');
}

function childrenAreElements<P>(children: ElementChildren): children is DeprecatedElement<P>[] {
  for (const child of children) {
    if (!(child instanceof DeprecatedElement)) {
      return false;
    }
  }

  return true;
}

/**
 * Note: non-string values that resolve to string output will count as Strings for our purposes
 * TODO: refactor and clarify exactly what we're doing here, and why. Possibly rewrite type definition 
 * and abstract JSXElement case into some other thing?
 */
function childrenContainsStringOutput<P>(children: ElementChildren): children is (string | number | boolean | DeprecatedElement<P>)[] {
  for (const child of children) {
    if (typeof child === 'string' || typeof child === 'number' || typeof child === 'boolean') {
      return true;
    }
  }

  return false;
}